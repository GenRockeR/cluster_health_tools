<form>
  <label>Debug Ingestion</label>
  <description>Another groovy debug dashboard from Richard Morgan</description>
  <init>
    <set token="_internal">(index=_internal OR index=core_splunk_internal)</set>
    <set token="series_thruput_max">0</set>
    <eval token="series_thruput_min">now()</eval>a</init>
  <search id="annotation_restarts">
    <query>| multisearch 
    [ search $_internal$ host=$selected_forwarder$ sourcetype=splunkd INFO component=loader splunkd starting build punct::--_::._+____-___\(_\). 
    | eval column="started" ] 
    [ search $_internal$ host=$selected_forwarder$ sourcetype=splunkd INFO ServerConfig my newly generated GUID is punct::--_::._+____-______---- 
    | eval column="new" ] 
    [ search $_internal$ host=$selected_forwarder$ sourcetype=splunkd INFO Shutdownhandler Shutting down splunkd punct::--_::._+____-___ 
    | eval column="shutdown" ] 
    [ search $_internal$ host=$selected_forwarder$ sourcetype=splunkd_crash_log build NOT Process NOT renamed CLOCK_MONOTONIC 
    | eval column="crash" ] 
| fields + _time host column 
| appendpipe 
    [| transaction startswith=(column="oom" OR column="crash" OR column="shutdown" OR column="new") endswith=(column="started") by host 
    | eval column=mvjoin(column,"-&gt;"), 
        _time=_time+duration] 
| where column!="started" 
| eval annotation_label=host, annotation_category=column</query>
    <earliest>$time.earliest$</earliest>
    <latest>$time.latest$</latest>
    <sampleRatio>1</sampleRatio>
  </search>
  <search id="thruput">
    <query>$_internal$ host=$selected_host$ METRICS TERM(group=thruput) TERM(name=*) NOT TERM(kb=0) NOT(name=idxsummary)
| fillnull ingest_pipe 0 
| bin _time span=31sec
| stats
    $selected_thruput_function$(instantaneous_kbps) as instantaneous_kbps
    $selected_thruput_function$(instantaneous_eps) as instantaneous_eps
    $selected_thruput_function$(average_kbps) as average_kbps
    $selected_thruput_function$(total_k_processed) as total_k_processed
    $selected_thruput_function$(kb) as kb
    $selected_thruput_function$(ev) as ev
    $selected_thruput_function$(load_average) as load_average
    by _time ingest_pipe name
    
</query>
    <earliest>$time.earliest$</earliest>
    <latest>$time.latest$</latest>
  </search>
  <search id="connecting_forwarders">
    <query>$_internal$ Metrics sourcetype=splunkd TERM(group=tcpin_connections) host=$selected_host$ earliest=$selection_per_series_earliest$ latest=$selection_per_series_latest$
| fillnull ingest_pipe 0
| eventstats dc(_time) as readings 
| stats 
    sum(kb) as sum_kb
    avg(chan_new_kBps) as avg_chan_new_kBps
    max(tcp_KBps) as max_tcp_KBps
    stdev(tcp_KBps) as stdev_tcp_KBps
    values(connectionType) as connectionType
    values(arch) as arch
    values(version) as version
    values(fwdType) as type
    values(ssl) as ssl
    values(os) as os
    values(guid) as guid
    dc(guid) as guid_count
    dc(sourceIp) as count_sources
    dc(_time) as mentions
    by hostname sourceHost sourcePort ingest_pipe readings
| eventstats 
    sum(max_tcp_KBps) as total_sum_avg_KBps
    stdev(tcp_KBps) as avg_stdev_KBps
    sum(sum_kb) as total_sum_kb 
    dc(guid) as all_forwarders 
    max(indexer_count) as all_indexers
    by ingest_pipe
| eval indexer_coverage=indexer_count."/".all_indexers,
indexer_coverage_pct=indexer_count/all_indexers
| sort 0 - sum_kb 
| streamstats 
    sum(sum_kb) as accumlated_sum_kb 
    count as ranking_most_data_kb
    by all_forwarders ingest_pipe
| eval coverage_kb=accumlated_sum_kb/total_sum_kb, 
    progress_through_forwarders_kb=(ranking_most_data_kb/all_forwarders) * 100 
| sort 0 - max_tcp_KBps 
| streamstats 
    sum(max_tcp_KBps) as accumlated_avg_kbps 
    count as ranking_most_data_kbps
    by all_forwarders ingest_pipe
| eval coverage_kbps=accumlated_avg_kbps/total_sum_avg_KBps, 
    progress_through_forwarders_kbps=(ranking_most_data_kbps/all_forwarders) * 100 
| rename ranking_most_data_kbps as "speed ranking" 
| rename ranking_most_data_kb as "volume ranking" 
| rename max_tcp_KBps as "max speed" 
| eval "%"='%'*100,
    "speed variability" = (stdev_tcp_KBps/'max speed')*100,
    "data"=sum_kb/1024/1024,
    "data %"= (sum_kb/total_sum_kb) * 100
$finished_per_series_thruput$   
    </query>
    <earliest>$selection_thruput_earliest$</earliest>
    <latest>$selection_thruput_latest$</latest>
  </search>
  <search id="per_series_thruput">
    <query>$_internal$ host=$selected_host$ METRICS sourcetype=splunkd TERM(kb=*) TERM(kbps=*) TERM(ev=*) TERM(eps=*) TERM(group=*) TERM(series=*)
| fillnull ingest_pipe 0
| table _time host group ingest_pipe series eps ev kbps kb max_age avg_age</query>
    <earliest>$time.earliest$</earliest>
    <latest>$time.latest$</latest>
  </search>
  <search id="pipeline_processor">
    <query>$_internal$ host=$selected_host$ METRICS METRICS TERM(group=pipeline) TERM(processor=*)
| fillnull ingest_pipe 0
| table _time host ingest_pipe processor name executes cpu_seconds cumulative_hits
| bin _time span=31sec 
</query>
    <earliest>$time.earliest$</earliest>
    <latest>$time.latest$</latest>
  </search>
  <search base="pipeline_processor" id="pipeline_processor_aggregated">
    <query>| stats avg(cpu_seconds) as cpu_seconds
    avg(executes) as executes
    avg(cumulative_hits) as cumulative_hits
    by _time processor ingest_pipe name</query>
  </search>
  <search id="annotation_blocking">
    <query>$_internal$ host=$selected_host$ source=*metrics* TERM(blocked=true) 
| stats values(name) as name by host _time ingest_pipe 
| eval 
    annotation_label= "pipeline #".ingest_pipe." blocked", 
    annotation_category=mvjoin(name,"+") 
| table _time anno* ingest_pipe</query>
    <earliest>$time.earliest$</earliest>
    <latest>$time.latest$</latest>
  </search>
  <search id="annotation_blocking_filtered" base="annotation_blocking">
    <query>
      | search ingest_pipe=$filter_pipelines$
    </query>
  </search>
  <search id="channels">
    <query>
$_internal$ host=$selected_host$ TERM(group=map) TERM(name=pipelineinputchannel)
| fillnull ingest_pipe 0 
| table _time host ingest_pipe current_size inactive_channels new_channels removed_channels reclaimed_channel timedout_channels abandoned_channels 
</query>
    <earliest>$time.earliest$</earliest>
    <latest>$time.latest$</latest>
  </search>
  <search id="queue">
    <query>$_internal$ Metrics sourcetype=splunkd host=$selected_host$ TERM(group=queue) NOT(largest_size=0) TERM(max_size_kb=*) NOT(current_size_kb=0)
| fillnull ingest_pipe 0 
| bin _time span=62sec 
| stats 
    avg(current_size_kb) as current_size_kb
    by _time ingest_pipe host name max_size_kb
| eval normalized_pct=(current_size_kb/max_size_kb) * 100
</query>
    <earliest>$time.earliest$</earliest>
    <latest>$time.latest$</latest>
  </search>
  <search id="tcp_out">
    <query>$_internal$ Metrics sourcetype=splunkd TERM(group=tcpout_connections) host=$selected_host$ 
| fillnull ingest_pipe 0 
| bin _time span=31sec 
| stats
    sum(tcp_Kprocessed) as tcp_Kprocessed
    median(tcp_avg_thruput) as tcp_avg_thruput
    sum(kb) as kb
    avg(tcp_eps) as tcp_eps
    by _time ingest_pipe name sourcePort destIp destPort
| table _time ingest_pipe name sourcePort destIp destPort tcp_Kprocessed tcp_avg_thruput tcp_eps kb
</query>
    <earliest>$time.earliest$</earliest>
    <latest>$time.latest$</latest>
  </search>
  <search id="annotation_broken_pipes">
    <query>$_internal$ host=$selected_host$ TcpInputProc Error encountered for connection Broken pipe from TERM(src=*) sourcetype=splunkd
| eval annotation_label=src,
    annotation_category="Dropped forwarder" 
| table _time ann*</query>
    <earliest>$time.earliest$</earliest>
    <latest>$time.latest$</latest>
  </search>
  <search id="annotation_parsing_problems">
    <query>$_internal$ sourcetype=splunkd WARN component=DateParserVerbose host=$selected_host$
| eval reason = case(searchmatch("Accepted time format has changed possibly indicating a problem in extracting timestamps"),"Accepted time format has changed possibly indicating a problem in extracting timestamps",
    searchmatch("The TIME_FORMAT specified is matching timestamps outside of the acceptable time window"),"The TIME_FORMAT specified is matching timestamps outside of the acceptable time window",
    searchmatch("A possible timestamp match is outside of the acceptable time window"),"A possible timestamp match is outside of the acceptable time window",
    searchmatch("Failed to parse timestamp. Defaulting to timestamp of previous event"),"Failed to parse timestamp. Defaulting to timestamp of previous event",
    searchmatch("Time parsed is too far away from the previous time"), "Time parsed is too far away from the previous time",
    searchmatch("Accepted time is suspiciously far away from the previous time but still accepted because it was extracted by the same pattern"), "Accepted time is suspiciously far away from the previous time but still accepted because it was extracted by the same pattern",
    searchmatch("Failed to parse timestamp in first MAX_TIMESTAMP_LOOKAHEAD"), "Failed to parse timestamp in first MAX_TIMESTAMP_LOOKAHEAD",
    searchmatch("The TIME_FORMAT specified is matching timestamps outside of the acceptable time window"),"The TIME_FORMAT specified is matching timestamps outside of the acceptable time window",
    searchmatch("The same timestamp has been used for consecutive times. If more than 200K events have the same timestamp, not all events may be retrieveable"), "The same timestamp has been used for consecutive times. If more than 200K events have the same timestamp, not all events may be retrieveable") 
| rex field=_raw "Context:\s+source(::|=)(?&lt;naughty_source&gt;[^\|]+)\|host(::|=)(?&lt;naughty_host&gt;[^\|]+)\|(?&lt;naughty_sourcetype&gt;[^\|]+)\|(?&lt;number&gt;\d+)" 
| table _time reason naughty* 
</query>
    <earliest>$time.earliest$</earliest>
    <latest>$time.latest$</latest>
  </search>
  <search id="per_series_thruput_filtered" base="per_series_thruput">
    <done>
      <set token="finished_per_series_thruput">| noop</set>
    </done>
    <query>| search group=per_$selected_group$_thruput ingest_pipe=$filter_pipelines$ 
| bin _time span=31sec 
| stats $selected_per_series_function$(eps) as eps
    $selected_per_series_function$(kb) as kb
    $selected_per_series_function$(ev) as ev
    $selected_per_series_function$(kbps) as kbps
    $selected_per_series_function$(max_age) as max_age
    $selected_per_series_function$(avg_age) as avg_age
    by _time series host</query>
  </search>
  <search id="channels_filtered" base="channels">
    <query>| search ingest_pipe=$filter_pipelines$ 
| timechart span=31sec limit=30
    $selected_channels_function$(current_size) as current_size
    $selected_channels_function$(inactive_channels) as inactive_channels
    $selected_channels_function$(new_channels) as new_channels
    $selected_channels_function$(removed_channels) as removed_channels
    $selected_channels_function$(reclaimed_channel) as reclaimed_channel
    $selected_channels_function$(timedout_channels) as timedout_channels
    $selected_channels_function$(abandoned_channels) as abandoned_channels
    by ingest_pipe
</query>
  </search>
  <search id="hec_token_base">
    <query>
            | tstats 
    avg(data.num_of_events) as num_of_events
    avg(data.num_of_parser_errors) as num_of_parser_errors
    avg(data.num_of_requests) as num_of_requests
    avg(data.num_of_requests_in_mint_format) as num_of_requests_in_mint_format
    avg(data.num_of_requests_to_disabled_token) as num_of_requests_to_disabled_token
    avg(data.total_bytes_indexed) as total_bytes_indexed
    avg(data.total_bytes_received) as total_bytes_received
    where index=_introspection data.series::http_event_collector_token host=$selected_host$ 
    by _time data.token_name data.format data.transport span=31sec

          </query>
    <earliest>$time.earliest$</earliest>
    <latest>$time.latest$</latest>
  </search>
  <fieldset submitButton="false">
    <input type="time" token="time">
      <label>Select forwarder</label>
      <default>
        <earliest>-60m@m</earliest>
        <latest>now</latest>
      </default>
      <change>
        <unset token="finished_per_series_thruput"></unset>
        <unset token="finished_per_series_thruput"></unset>
        <set token="series_thruput_max">0</set>
        <eval token="series_thruput_min">now()</eval>
      </change>
    </input>
    <input type="text" token="selected_host">
      <label>Enter forwarder name</label>
      <change>
        <unset token="filter_pipelines"></unset>
        <unset token="show_tcp_out_panel"></unset>
      </change>
    </input>
    <input type="dropdown" token="filter_pipelines">
      <label>Filter to pipeline</label>
      <choice value="*">*</choice>
      <default>*</default>
      <fieldForLabel>ingest_pipe</fieldForLabel>
      <fieldForValue>ingest_pipe</fieldForValue>
      <search base="thruput">
        <query>
          | stats count by ingest_pipe
        </query>
      </search>
    </input>
  </fieldset>
  <row rejects="$selected_host$">
    <panel>
      <html>
        <h1 style="text-align:center">Please enter an exact hostname</h1>
      </html>
    </panel>
  </row>
  <row depends="$selected_host$">
    <panel>
      <title>The throughput per pipeline for $selected_host$ for all pipelines - select a pipeline for more detail</title>
      <input type="dropdown" token="selected_thruput">
        <label>Select thruput metric</label>
        <choice value="thruput">thruput</choice>
        <fieldForLabel>name</fieldForLabel>
        <fieldForValue>name</fieldForValue>
        <search base="thruput">
          <query>| stats count by name
| where name != "thruput"</query>
        </search>
        <default>thruput</default>
      </input>
      <input type="dropdown" token="selected_thruput_variable">
        <label>Select field to show</label>
        <choice value="instantaneous_kbps">instantaneous_kbps</choice>
        <choice value="instantaneous_eps">instantaneous_eps</choice>
        <choice value="average_kbps">average_kbps</choice>
        <choice value="total_k_processed">total_k_processed</choice>
        <choice value="kb">kb</choice>
        <choice value="ev">ev</choice>
        <default>instantaneous_kbps</default>
      </input>
      <input type="dropdown" token="selected_thruput_function">
        <label>Select aggregation function</label>
        <choice value="avg">average</choice>
        <choice value="median">median</choice>
        <choice value="mean">mean</choice>
        <choice value="stdev">standard dev</choice>
        <choice value="per_second">per_second</choice>
        <choice value="p90">p90</choice>
        <choice value="p95">p95</choice>
        <choice value="p99">p99</choice>
        <choice value="max">max</choice>
        <choice value="min">min</choice>
        <choice value="sum">sum</choice>
        <choice value="range">range</choice>
        <choice value="var">variance</choice>
        <default>avg</default>
      </input>
      <chart>
        <search base="annotation_blocking" type="annotation"></search>
        <search base="thruput">
          <query>| search name=$selected_thruput$ 
| timechart span=31sec limit=0 
    avg($selected_thruput_variable$) by ingest_pipe 
| eval *=0 
| foreach * 
    [| eval *='*'+if(isnotnull('&lt;&lt;FIELD&gt;&gt;'),'&lt;&lt;FIELD&gt;&gt;',0)]</query>
        </search>
        <option name="charting.axisY2.enabled">1</option>
        <option name="charting.chart">column</option>
        <option name="charting.chart.overlayFields">*</option>
        <option name="charting.chart.stackMode">stacked</option>
        <option name="charting.drilldown">all</option>
        <option name="charting.legend.placement">top</option>
        <option name="height">461</option>
        <option name="refresh.display">progressbar</option>
        <drilldown>
          <set token="form.filter_pipelines">$click.name2$</set>
        </drilldown>
        <selection>
          <set token="selection_thruput_earliest">$start$</set>
          <set token="selection_thruput_latest">$end$</set>
        </selection>
      </chart>
    </panel>
  </row>
  <row depends="$selected_host$">
    <panel>
      <html>
        <h2 style="text-align:center">
        <a target="_blank" rel="noopener noreferrer" href="forwarder_performance?form.time.earliest=$time.earliest$&amp;form.time.latest=$time.latest$&amp;form.selected_host=$selected_host$">Open this dashboard in a new window with absolute for selected range time</a>
        </h2>
      </html>
    </panel>
  </row>
  <row depends="$selected_host$" rejects="$show_hec_panel$">
    <panel>
      <title>HEC details per token - not pipeline aware</title>
      <html>
        <h1 style="text-align:center">No HEC ingestion detected</h1>
      </html>
    </panel>
  </row>
  <row depends="$selected_host$,$show_hec_panel$">
    <panel>
      <title>HEC details per token - not pipeline aware</title>
      <input type="multiselect" token="selected_hec_fields">
        <label>Select attribute</label>
        <choice value="avg(num_of_events)">num_of_events</choice>
        <choice value="avg(num_of_parser_errors)">num_of_parser_errors</choice>
        <choice value="avg(num_of_requests)">num_of_requests</choice>
        <choice value="avg(num_of_requests_in_mint_format)">num_of_requests_in_mint_format</choice>
        <choice value="avg(num_of_requests_to_disabled_token)">num_of_requests_to_disabled_token</choice>
        <choice value="avg(total_bytes_indexed)">total_bytes_indexed</choice>
        <choice value="avg(total_bytes_received)">total_bytes_received</choice>
        <delimiter> </delimiter>
        <default>avg(total_bytes_indexed),avg(total_bytes_received),avg(num_of_events),avg(num_of_parser_errors)</default>
      </input>
      <input type="dropdown" token="hec_split_by">
        <label>Split HEC data by</label>
        <choice value="by data.format">format</choice>
        <choice value="by data.token_name">token_name</choice>
        <choice value="by data.transport">transport</choice>
        <choice value="| noop">no split</choice>
        <default>| noop</default>
      </input>
      <input type="dropdown" token="selected_hec_token">
        <label>Select HEC token</label>
        <choice value="*">*</choice>
        <fieldForLabel>data.token_name</fieldForLabel>
        <fieldForValue>data.token_name</fieldForValue>
        <search base="hec_token_base">
          <query>| stats count by data.token_name </query>
          <done>
            <eval token="show_hec_panel">if($job.resultCount$=0,NULL,"| noop")</eval>
          </done>
        </search>
        <default>*</default>
      </input>
      <chart>
        <title>Select window and indexer to drill in</title>
        <search base="annotation" type="annotation"></search>
        <search base="hec_token_base">
          <query>| search data.token_name=$selected_hec_token$
| timechart $selected_hec_fields$ $hec_split_by$</query>
        </search>
        <option name="charting.axisY.scale">log</option>
        <option name="charting.chart">line</option>
        <option name="charting.drilldown">none</option>
        <option name="charting.legend.placement">top</option>
        <option name="height">377</option>
        <option name="refresh.display">progressbar</option>
      </chart>
    </panel>
  </row>
  <row depends="$selected_host$">
    <panel>
      <title>Load average for $selected_host$ with annotated restarts</title>
      <input type="dropdown" token="selected_load_average_function">
        <label>Select aggregation function</label>
        <choice value="avg">average</choice>
        <choice value="median">median</choice>
        <choice value="mean">mean</choice>
        <choice value="stdev">standard dev</choice>
        <choice value="per_second">per_second</choice>
        <choice value="p90">p90</choice>
        <choice value="p95">p95</choice>
        <choice value="p99">p99</choice>
        <choice value="max">max</choice>
        <choice value="min">min</choice>
        <choice value="sum">sum</choice>
        <choice value="range">range</choice>
        <choice value="var">variance</choice>
        <default>avg</default>
      </input>
      <chart>
        <search base="thruput">
          <query>| search name=thruput 
| fields _time load_average 
| timechart span=31sec $selected_load_average_function$(load_average) as load_average</query>
        </search>
        <search base="annotation_restarts" type="annotation"></search>
        <option name="charting.chart">line</option>
        <option name="charting.drilldown">none</option>
        <option name="refresh.display">progressbar</option>
      </chart>
    </panel>
  </row>
  <row depends="$selected_host$" rejects="$show_queue_panel$">
    <panel>
      <title>Queue filling for pipeline $filter_pipelines$ on $selected_host$</title>
      <html>
        <h1 style="text-align:center">No blocking detected</h1>
      </html>
    </panel>
  </row>
  <row depends="$selected_host$,$show_queue_panel$">
    <panel>
      <title>Queue filling for pipeline $filter_pipelines$ on $selected_host$</title>
      <input type="dropdown" token="queue_fill">
        <label>Queue fill measure</label>
        <choice value="normalized_pct">Normalized %</choice>
        <choice value="current_size_kb">Absolute</choice>
        <default>current_size_kb</default>
      </input>
      <chart>
        <search base="annotation_blocking_filtered" type="annotation">
          <query/>
        </search>
        <search base="queue">
          <query>| search ingest_pipe=$filter_pipelines$ 
| timechart span=31sec avg($queue_fill$) by name</query>
          <done>
            <eval token="show_queue_panel">if($job.resultCount$=0,NULL,"| noop")</eval>
          </done>
        </search>
        <option name="charting.chart">column</option>
        <option name="charting.chart.stackMode">stacked</option>
        <option name="charting.drilldown">none</option>
        <option name="charting.legend.placement">top</option>
        <option name="height">353</option>
        <option name="refresh.display">progressbar</option>
      </chart>
    </panel>
  </row>
  <row depends="$selected_host$">
    <panel>
      <title>Throughput for $selected_group$ on $filter_pipelines$ on $selected_host$</title>
      <input type="dropdown" token="selected_group">
        <label>Select series</label>
        <choice value="index">per_index_thruput</choice>
        <choice value="host">per_host_thruput</choice>
        <choice value="source">per_source_thruput</choice>
        <choice value="sourcetype">per_sourcetype_thruput</choice>
        <default>sourcetype</default>
      </input>
      <input type="dropdown" token="selected_per_series_variable">
        <label>Select field to show</label>
        <choice value="kb">kb</choice>
        <choice value="eps">eps</choice>
        <choice value="ev">ev</choice>
        <choice value="kbps">kbps</choice>
        <choice value="max_age">max_age</choice>
        <choice value="avg_age">avg_age</choice>
        <default>eps</default>
      </input>
      <input type="dropdown" token="selected_per_series_function">
        <label>Select aggregation function</label>
        <choice value="avg">average</choice>
        <choice value="median">median</choice>
        <choice value="mean">mean</choice>
        <choice value="stdev">standard dev</choice>
        <choice value="per_second">per_second</choice>
        <choice value="p90">p90</choice>
        <choice value="p95">p95</choice>
        <choice value="p99">p99</choice>
        <choice value="max">max</choice>
        <choice value="min">min</choice>
        <choice value="sum">sum</choice>
        <choice value="range">range</choice>
        <choice value="var">variance</choice>
        <default>avg</default>
      </input>
      <chart>
        <title>Select range to reveal what forwarders where connecting to what pipelines for the duration</title>
        <search base="annotation_parsing_problems" type="annotation">
          <query>
            
| eval annotation_label=naughty_$selected_group$,
    annotation_category=reason
| table _time anno*


          </query>
        </search>
        <search base="per_series_thruput_filtered">
          <done>
            <set token="finished_per_series_thruput">| noop</set>
          </done>
          <query>
| timechart span=31sec limit=30 $selected_per_series_function$($selected_per_series_variable$) as kb by series</query>
        </search>
        <selection>
          <eval token="series_thruput_max">if($end$&gt;$series_thruput_max$,$end$,$series_thruput_max$)</eval>
          <eval token="series_thruput_min">if($start$&lt;$series_thruput_min$,$start$,$series_thruput_min$)</eval>
          <eval token="selection_per_series_earliest">if(isnotnull($finished_per_series_thruput$) AND $start$!=$series_thruput_min$, $start$, NULL)</eval>
          <eval token="selection_per_series_latest">if(isnotnull($finished_per_series_thruput$) AND $end$ != $series_thruput_max$, $end$, NULL)</eval>
        </selection>
        <option name="charting.chart">column</option>
        <option name="charting.chart.stackMode">stacked</option>
        <option name="charting.drilldown">none</option>
        <option name="charting.legend.placement">top</option>
        <option name="height">419</option>
        <option name="refresh.display">progressbar</option>
      </chart>
    </panel>
  </row>
  <row depends="$finished_per_series_thruput$,$selection_per_series_earliest$,$selection_per_series_latest$">
    <panel>
      <title>Forwarders connecting to $selected_host$ showing $selected_host_count$ forwarders</title>
      <input type="dropdown" token="selected_host_version">
        <label>Filter forwarder version</label>
        <choice value="*">*</choice>
        <search base="connecting_forwarders">
          <query>| stats count by version
| eval label=version." (".count." instances)"</query>
        </search>
        <fieldForLabel>label</fieldForLabel>
        <fieldForValue>version</fieldForValue>
        <default>*</default>
      </input>
      <input type="dropdown" token="selected_host_type">
        <label>Filter forwarder type</label>
        <choice value="*">*</choice>
        <search base="connecting_forwarders">
          <query>| stats count by type
| eval label=type." (".count." instances)"
| sort - count</query>
        </search>
        <fieldForLabel>label</fieldForLabel>
        <fieldForValue>type</fieldForValue>
        <default>*</default>
      </input>
      <input type="dropdown" token="selected_host_os">
        <label>Filter forwarder OS</label>
        <choice value="*">*</choice>
        <search base="connecting_forwarders">
          <query>| stats count by os
| eval label=os." (".count." instances)"
| sort - count</query>
        </search>
        <fieldForLabel>label</fieldForLabel>
        <fieldForValue>os</fieldForValue>
        <default>*</default>
      </input>
      <table>
        <title>For more detail click on some forwarders and more charts will open allowing you to compare performance and behaviours of those you selected</title>
        <search base="connecting_forwarders">
          <progress>
            <set token="selected_host_count">$job.resultCount$</set>
          </progress>
          <done>
            <set token="selected_host_count">$job.resultCount$</set>
          </done>
          <query>| search type=$selected_host_type$ os=$selected_host_os$ version=$selected_host_version$ ingest_pipe=$filter_pipelines$
| rename guid_count as "# guids"
| eval "connected for"=mentions."/".readings, "connected %"=(mentions/readings)* 100
| table hostname sourceHost sourcePort guid guid_count ingest_pipe "volume ranking" "speed ranking" "indexer coverage"  "%" "connected for" "connected %" "max speed" "speed variability" "data" "data %" "os" "type" "version" arch 
| sort 0 - "data"
| rename ingest_pipe as "ingest pipe"</query>
        </search>
        <option name="count">20</option>
        <option name="drilldown">cell</option>
        <option name="refresh.display">progressbar</option>
        <format type="number" field="indexer coverage">
          <option name="precision">0</option>
          <option name="unit">%</option>
        </format>
        <format type="number" field="max speed">
          <option name="precision">0</option>
          <option name="unit">KBps</option>
        </format>
        <format type="number" field="speed variability">
          <option name="precision">0</option>
          <option name="unit">%</option>
        </format>
        <format type="color" field="%">
          <colorPalette type="list">[#D93F3C,#FFFFFF]</colorPalette>
          <scale type="threshold">99</scale>
        </format>
        <format type="color" field="max speed">
          <colorPalette type="minMidMax" maxColor="#31A35F" minColor="#FFFFFF"></colorPalette>
          <scale type="minMidMax"></scale>
        </format>
        <format type="color" field="speed variability">
          <colorPalette type="minMidMax" maxColor="#1E93C6" minColor="#FFFFFF"></colorPalette>
          <scale type="minMidMax"></scale>
        </format>
        <format type="number" field="data">
          <option name="unit">GB</option>
        </format>
        <format type="color" field="data">
          <colorPalette type="minMidMax" maxColor="#31A35F" minColor="#FFFFFF"></colorPalette>
          <scale type="minMidMax"></scale>
        </format>
        <format type="number" field="data %">
          <option name="precision">0</option>
          <option name="unit">%</option>
        </format>
        <format type="color" field="data %">
          <colorPalette type="minMidMax" maxColor="#31A35F" minColor="#FFFFFF"></colorPalette>
          <scale type="minMidMax"></scale>
        </format>
        <format type="number" field="%">
          <option name="precision">0</option>
        </format>
        <format type="number" field="connected %">
          <option name="precision">0</option>
          <option name="unit">%</option>
        </format>
        <format type="color" field="connected %">
          <colorPalette type="list">[#FFFFFF,#D93F3C]</colorPalette>
          <scale type="threshold">80</scale>
        </format>
        <drilldown>
          <link target="_blank">forwarder_performance?form.selected_host=$row.hostname$&amp;form.time.earliest=$time.earliest$&amp;form.time.latest=$time.latest$</link>
        </drilldown>
      </table>
    </panel>
  </row>
  <row depends="$finished_per_series_thruput$,$selection_per_series_earliest$,$selection_per_series_latest$">
    <panel>
      <title>Parsing problems $selected_host$ for all pipelines</title>
      <table>
        <search base="annotation_parsing_problems">
          <query>| search _time&gt;$selection_per_series_earliest$ _time&lt;$selection_per_series_latest$
| stats count values(reason) as reason by naughty_host naughty_sourcetype naughty_source
| sort - count</query>
        </search>
        <option name="count">10</option>
        <option name="refresh.display">progressbar</option>
        <drilldown>
          <link target="_self">/app/search/forwarder_performance?form.selected_sourcetype=$row.naughty_sourcetype$&amp;form.selected_source=$row.naughty_source$&amp;form.selected_host=$row.naughty_host$&amp;form.earliest=asdf&amp;form.latest=asdf</link>
        </drilldown>
      </table>
    </panel>
  </row>
  <row depends="$selected_host$">
    <panel>
      <title>Pipeline processor cpu and execution for pipeline $filter_pipelines$ on $selected_host$</title>
      <input type="dropdown" token="selected_processor_function">
        <label>Select aggregation function</label>
        <choice value="avg">average</choice>
        <choice value="median">median</choice>
        <choice value="mean">mean</choice>
        <choice value="stdev">standard dev</choice>
        <choice value="per_second">per_second</choice>
        <choice value="p90">p90</choice>
        <choice value="p95">p95</choice>
        <choice value="p99">p99</choice>
        <choice value="max">max</choice>
        <choice value="min">min</choice>
        <choice value="sum">sum</choice>
        <choice value="range">range</choice>
        <choice value="var">variance</choice>
        <default>avg</default>
      </input>
      <input type="dropdown" token="selected_processor">
        <label>Select process and name</label>
        <choice value="processor=* name=*">processor=* name=*</choice>
        <default>processor=* name=*</default>
        <fieldForLabel>search</fieldForLabel>
        <fieldForValue>search</fieldForValue>
        <search base="pipeline_processor_aggregated">
          <query>| stats count by processor name 
| eval search="processor=".processor." name=".name 
| appendpipe 
    [| stats count by name 
    | eval search="name=".name." processor=*"]

| appendpipe 
    [| stats count by processor 
    | eval search="name=* processor=".processor]</query>
        </search>
      </input>
      <input type="dropdown" token="selected_processor_variable">
        <label>Select variable to plot</label>
        <choice value="cpu_seconds">cpu_seconds</choice>
        <choice value="executes">executes</choice>
        <choice value="cumulative_hits">cumulative_hits</choice>
        <default>cpu_seconds</default>
      </input>
      <chart>
        <search base="pipeline_processor_aggregated">
          <query>| search ingest_pipe=$filter_pipelines$ $selected_processor$ 
| eval key="#".ingest_pipe." ".processor." &amp; ".name 
| timechart limit=50 span=31sec avg($selected_processor_variable$) by key</query>
        </search>
        <search base="annotation_parsing_problems" type="annotation">| eval annotation_label=naughty_$selected_group$,
    annotation_category=reason
| table _time anno*</search>
        <option name="charting.chart">line</option>
        <option name="charting.drilldown">none</option>
        <option name="charting.legend.placement">top</option>
        <option name="height">484</option>
        <option name="refresh.display">progressbar</option>
      </chart>
    </panel>
  </row>
  <row depends="$selected_host$">
    <panel>
      <title>Channel creation for pipeline $filter_pipelines$ on $selected_host$</title>
      <input type="dropdown" token="channel_variable">
        <label>Select channel metric</label>
        <choice value="current_size*">current_size</choice>
        <choice value="inactive_channels*">inactive_channels</choice>
        <choice value="new_channels*">new_channels</choice>
        <choice value="removed_channels*">removed_channels</choice>
        <choice value="reclaimed_channels*">reclaimed_channels</choice>
        <choice value="timedout_channels*">timedout_channels</choice>
        <choice value="abandoned_channels*">abandoned_channels</choice>
        <choice value="*">*</choice>
        <default>*</default>
      </input>
      <input type="dropdown" token="selected_channels_function">
        <label>Select aggregation function</label>
        <choice value="avg">average</choice>
        <choice value="median">median</choice>
        <choice value="mean">mean</choice>
        <choice value="stdev">standard dev</choice>
        <choice value="per_second">per_second</choice>
        <choice value="p90">p90</choice>
        <choice value="p95">p95</choice>
        <choice value="p99">p99</choice>
        <choice value="max">max</choice>
        <choice value="min">min</choice>
        <choice value="sum">sum</choice>
        <choice value="range">range</choice>
        <choice value="var">variance</choice>
        <default>avg</default>
      </input>
      <chart>
        <search base="annotation_broken_pipes" type="annotation">
          <query>
            $_internal$ host=$selected_host$ TcpInputProc Error encountered for connection Broken pipe from TERM(src=*) sourcetype=splunkd
| eval annotation_label=src,
    annotation_category="Dropped forwarder" 
| table _time ann*
          </query>
        </search>
        <search base="channels_filtered">
          <query>
| fields _time $channel_variable$</query>
        </search>
        <option name="charting.chart">column</option>
        <option name="charting.chart.stackMode">stacked</option>
        <option name="charting.drilldown">none</option>
        <option name="charting.legend.placement">top</option>
        <option name="height">467</option>
        <option name="refresh.display">progressbar</option>
      </chart>
    </panel>
  </row>
  <row depends="$selected_host$" rejects="$show_tcp_out_panel$">
    <panel>
      <title>TCP output metrics for pipeline $filter_pipelines$ on $selected_host$</title>
      <html>
        <h1 style="text-align:center">No TCP out on $selected_host$, host is most likely to be an indexer</h1>
      </html>
    </panel>
  </row>
  <row depends="$selected_host$,$show_tcp_out_panel$">
    <panel>
      <title>TCP output metrics for pipeline $filter_pipelines$ on $selected_host$</title>
      <input type="dropdown" token="tcp_out_variable">
        <label>Select variable</label>
        <choice value="tcp_Kprocessed">tcp_Kprocessed</choice>
        <choice value="tcp_avg_thruput">tcp_avg_thruput</choice>
        <choice value="tcp_eps">tcp_eps</choice>
        <choice value="kb">kb</choice>
        <default>tcp_avg_thruput</default>
      </input>
      <input type="dropdown" token="tcp_out_splitby">
        <label>Select variable</label>
        <choice value="destIp">destIp</choice>
        <choice value="name">name</choice>
        <choice value="channel">channel</choice>
        <choice value="group">group</choice>
        <default>destIp</default>
      </input>
      <chart>
        <title>$selected_earliest$ $selected_latest$   $selected_name2$</title>
        <search id="annotation_timeout" type="annotation">
          <query>
$_internal$ host=$selected_host$ sourcetype=splunkd TERM(statusee=TcpOutputProcessor) TERM(eventType=connect_fail) StatusMgr
| eval annotation_label="connect fail",
    annotation_category=destHost
$show_tcp_out_panel$    
    </query>
          <earliest>$time.earliest$</earliest>
          <latest>$time.latest$</latest>
        </search>
        <search base="tcp_out">
          <done>
            <eval token="show_tcp_out_panel">if($job.resultCount$=0,NULL,"| noop")</eval>
          </done>
          <query>| search ingest_pipe=$filter_pipelines$ 
| rex field=name "^(?&lt;group&gt;[^:]+):[^:]+:[^:]+:(?&lt;channel&gt;\d+)"
| timechart limit=80 avg($tcp_out_variable$) by $tcp_out_splitby$</query>
        </search>
        <option name="charting.chart">column</option>
        <option name="charting.chart.stackMode">stacked</option>
        <option name="charting.drilldown">none</option>
        <option name="charting.legend.placement">top</option>
        <option name="height">412</option>
        <option name="refresh.display">progressbar</option>
        <selection>
          <eval token="selection_earliest_tcp_out">$start$</eval>
          <eval token="selection_latest_tcp_out">$end$</eval>
        </selection>
      </chart>
    </panel>
  </row>
  <row depends="$selected_host$,$selection_earliest_tcp_out$,$selection_latest_tcp_out$">
    <panel>
      <title>Targets recieving data from $selected_host$ for selected duration</title>
      <chart>
        <title>Drill down to select upstream target</title>
        <search>
          <query>$_internal$ TERM(hostname=$selected_host$) earliest=$selection_earliest_tcp_out$ latest=$selection_latest_tcp_out$ 
| fillnull ingest_pipe 0
| sort host
| chart sum(kb) as kb 
    by host ingest_pipe</query>
          <earliest>$selection_earliest_tcp_out$</earliest>
          <latest>$selection_latest_tcp_out$</latest>
        </search>
        <option name="charting.chart">column</option>
        <option name="charting.chart.stackMode">stacked</option>
        <option name="charting.drilldown">all</option>
        <option name="charting.legend.placement">none</option>
        <option name="height">423</option>
        <option name="refresh.display">progressbar</option>
        <drilldown>
          <link target="_blank">/app/search/forwarder_performance?form.selected_host=$click.value$&amp;form.time.earliest=$selection_earliest_tcp_out$&amp;form.time.latest=$selection_latest_tcp_out$&amp;form.ingest_pipe=$click.name$</link>
        </drilldown>
      </chart>
    </panel>
  </row>
</form>
